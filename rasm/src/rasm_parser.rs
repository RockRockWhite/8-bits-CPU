use serde::{Deserialize, Serialize};
use std::{collections::HashMap, error::Error, hash::Hash};

// declarations
// ======================

pub struct Foo {
    x: i32,
    y: i32,
}

// ======================

/// Token
/// must implement Clone and Token trait
/// Token trait is used to convert a token to a tree node
pub trait Token: Clone {
    fn to_tree_node(&self) -> ParsingTreeNode;
}

pub struct ParsingTreeNode {
    pub symbol_type: String,
    pub data: String,
    pub children: Vec<ParsingTreeNode>,
}

impl ParsingTreeNode {
    pub fn build(symbol_type: String, data: String, children: Vec<ParsingTreeNode>) -> Self {
        ParsingTreeNode {
            symbol_type,
            data,
            children,
        }
    }
}

/// NodePair
/// a pair of a node and a state.
/// (TreeNode, state)
pub struct NodePair(ParsingTreeNode, usize);
impl NodePair {
    pub fn new(node: ParsingTreeNode, state: usize) -> Self {
        NodePair(node, state)
    }
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct ReduceDerivation {
    pub left: String,
    pub right: Vec<String>,
}

impl PartialEq for ReduceDerivation {
    fn eq(&self, other: &Self) -> bool {
        self.left == other.left && self.right == other.right
    }
}

impl Eq for ReduceDerivation {}

impl Hash for ReduceDerivation {
    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {
        self.left.hash(state);
        self.right.hash(state);
    }
}

impl ReduceDerivation {
    pub fn build(left: String, right: Vec<String>) -> Self {
        ReduceDerivation { left, right }
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub enum Action {
    Shift(usize),
    Reduce(ReduceDerivation),
    Accept,
    Error,
}

#[derive(Serialize, Deserialize)]
pub struct State {
    pub actions: HashMap<String, Action>,
}

impl State {
    pub fn new() -> Self {
        State {
            actions: HashMap::new(),
        }
    }
}

#[derive(Serialize, Deserialize, Default)]
pub struct ActionTable {
    pub states: Vec<State>,
}

impl ActionTable {
    pub fn get_action(&self, state: usize, symbol: &str) -> Option<&Action> {
        self.states[state].actions.get(symbol)
    }
}

#[derive(Default)]
pub struct RParser {
    action_table: ActionTable,
    handlers: HashMap<ReduceDerivation, Box<dyn Fn(Vec<String>) -> String>>,
    // variables
    // ======================
    pub a: i32,
    pub b: i64,
    // ======================
}

impl RParser {
    pub const END_SYMBOL: &'static str = "__$__";
    pub const EPSILON_SYMBOL: &'static str = "__EPSILON__";
    pub const DUMMY_START_SYMBOL: &'static str = "__DUMMY_START__";

    pub fn new() -> Self {
        // action table generated by rparser
        // ======================
        let action_table: ActionTable =  serde_json::from_str(r#"{"states":[{"actions":{"__$__":"Accept","S":{"Shift":1},"mv":{"Shift":7},"lb":{"Shift":19},"nop":{"Shift":11},"instructions":{"Shift":23},"hlt":{"Shift":17},"li":{"Shift":2},"instruction":{"Shift":12},"sb":{"Shift":13},"program":{"Shift":6}}},{"actions":{"__$__":{"Reduce":{"left":"__DUMMY_START__","right":["S"]}}}},{"actions":{"register":{"Shift":3}}},{"actions":{"comma":{"Shift":4}}},{"actions":{"number":{"Shift":5}}},{"actions":{"mv":{"Reduce":{"left":"instruction","right":["li","register","comma","number"]}},"sb":{"Reduce":{"left":"instruction","right":["li","register","comma","number"]}},"lb":{"Reduce":{"left":"instruction","right":["li","register","comma","number"]}},"nop":{"Reduce":{"left":"instruction","right":["li","register","comma","number"]}},"__$__":{"Reduce":{"left":"instruction","right":["li","register","comma","number"]}},"hlt":{"Reduce":{"left":"instruction","right":["li","register","comma","number"]}},"li":{"Reduce":{"left":"instruction","right":["li","register","comma","number"]}}}},{"actions":{"__$__":{"Reduce":{"left":"S","right":["program"]}}}},{"actions":{"register":{"Shift":8}}},{"actions":{"comma":{"Shift":9}}},{"actions":{"register":{"Shift":10}}},{"actions":{"nop":{"Reduce":{"left":"instruction","right":["mv","register","comma","register"]}},"__$__":{"Reduce":{"left":"instruction","right":["mv","register","comma","register"]}},"lb":{"Reduce":{"left":"instruction","right":["mv","register","comma","register"]}},"hlt":{"Reduce":{"left":"instruction","right":["mv","register","comma","register"]}},"li":{"Reduce":{"left":"instruction","right":["mv","register","comma","register"]}},"sb":{"Reduce":{"left":"instruction","right":["mv","register","comma","register"]}},"mv":{"Reduce":{"left":"instruction","right":["mv","register","comma","register"]}}}},{"actions":{"mv":{"Reduce":{"left":"instruction","right":["nop"]}},"li":{"Reduce":{"left":"instruction","right":["nop"]}},"hlt":{"Reduce":{"left":"instruction","right":["nop"]}},"lb":{"Reduce":{"left":"instruction","right":["nop"]}},"sb":{"Reduce":{"left":"instruction","right":["nop"]}},"__$__":{"Reduce":{"left":"instruction","right":["nop"]}},"nop":{"Reduce":{"left":"instruction","right":["nop"]}}}},{"actions":{"sb":{"Shift":13},"hlt":{"Shift":17},"instruction":{"Shift":12},"nop":{"Shift":11},"__$__":{"Reduce":{"left":"instructions","right":[]}},"li":{"Shift":2},"instructions":{"Shift":18},"mv":{"Shift":7},"lb":{"Shift":19}}},{"actions":{"register":{"Shift":14}}},{"actions":{"comma":{"Shift":15}}},{"actions":{"number":{"Shift":16}}},{"actions":{"li":{"Reduce":{"left":"instruction","right":["sb","register","comma","number"]}},"mv":{"Reduce":{"left":"instruction","right":["sb","register","comma","number"]}},"lb":{"Reduce":{"left":"instruction","right":["sb","register","comma","number"]}},"hlt":{"Reduce":{"left":"instruction","right":["sb","register","comma","number"]}},"sb":{"Reduce":{"left":"instruction","right":["sb","register","comma","number"]}},"nop":{"Reduce":{"left":"instruction","right":["sb","register","comma","number"]}},"__$__":{"Reduce":{"left":"instruction","right":["sb","register","comma","number"]}}}},{"actions":{"mv":{"Reduce":{"left":"instruction","right":["hlt"]}},"li":{"Reduce":{"left":"instruction","right":["hlt"]}},"lb":{"Reduce":{"left":"instruction","right":["hlt"]}},"sb":{"Reduce":{"left":"instruction","right":["hlt"]}},"__$__":{"Reduce":{"left":"instruction","right":["hlt"]}},"hlt":{"Reduce":{"left":"instruction","right":["hlt"]}},"nop":{"Reduce":{"left":"instruction","right":["hlt"]}}}},{"actions":{"__$__":{"Reduce":{"left":"instructions","right":["instruction","instructions"]}}}},{"actions":{"register":{"Shift":20}}},{"actions":{"comma":{"Shift":21}}},{"actions":{"number":{"Shift":22}}},{"actions":{"sb":{"Reduce":{"left":"instruction","right":["lb","register","comma","number"]}},"hlt":{"Reduce":{"left":"instruction","right":["lb","register","comma","number"]}},"nop":{"Reduce":{"left":"instruction","right":["lb","register","comma","number"]}},"__$__":{"Reduce":{"left":"instruction","right":["lb","register","comma","number"]}},"mv":{"Reduce":{"left":"instruction","right":["lb","register","comma","number"]}},"li":{"Reduce":{"left":"instruction","right":["lb","register","comma","number"]}},"lb":{"Reduce":{"left":"instruction","right":["lb","register","comma","number"]}}}},{"actions":{"__$__":{"Reduce":{"left":"program","right":["instructions"]}}}}]}"#).unwrap();
        // ======================

        let mut handlers: HashMap<ReduceDerivation, Box<dyn Fn(Vec<String>) -> String>> =
            HashMap::new();

        // handlers generated by rparser
        // ======================
        handlers.insert(
            ReduceDerivation::build("S".into(), vec!["program".into()]),
            Box::new(|datas| {
                println!("S -> program");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build("program".into(), vec!["instructions".into()]),
            Box::new(|datas| {
                println!("program -> instructions");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build(
                "instructions".into(),
                vec!["instruction".into(), "instructions".into()],
            ),
            Box::new(|datas| {
                println!("instructions -> instruction instructions");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build("instructions".into(), vec![]),
            Box::new(|datas| {
                println!("instructions -> Îµ");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build(
                "instruction".into(),
                vec![
                    "li".into(),
                    "register".into(),
                    "comma".into(),
                    "number".into(),
                ],
            ),
            Box::new(|datas| {
                println!("instruction -> li register comma number");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build(
                "instruction".into(),
                vec![
                    "mv".into(),
                    "register".into(),
                    "comma".into(),
                    "register".into(),
                ],
            ),
            Box::new(|datas| {
                println!("instruction -> li register comma register");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build(
                "instruction".into(),
                vec![
                    "lb".into(),
                    "register".into(),
                    "comma".into(),
                    "number".into(),
                ],
            ),
            Box::new(|datas| {
                println!("instruction -> lb register comma number");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build(
                "instruction".into(),
                vec![
                    "sb".into(),
                    "register".into(),
                    "comma".into(),
                    "number".into(),
                ],
            ),
            Box::new(|datas| {
                println!("instruction -> sb register comma number");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build("instruction".into(), vec!["nop".into()]),
            Box::new(|datas| {
                println!("instruction -> nop");
                "".to_string()
            }),
        );
        handlers.insert(
            ReduceDerivation::build("instruction".into(), vec!["hlt".into()]),
            Box::new(|datas| {
                println!("instruction -> hlt");
                "".to_string()
            }),
        );
        // ======================

        handlers.insert(
            ReduceDerivation::build(Self::DUMMY_START_SYMBOL.into(), vec!["S".into()]),
            Box::new(|vals| vals[0].clone()),
        );

        let mut res: RParser = RParser::default();
        res.action_table = action_table;
        res.handlers = handlers;
        res
    }

    // do shift-reduce parsing
    pub fn parse<T>(&self, tokens: Vec<T>) -> Result<ParsingTreeNode, Box<dyn Error>>
    where
        T: Token,
    {
        let mut shift_index = 0;
        let mut stack: Vec<NodePair> = Vec::new();

        stack.push(NodePair::new(
            ParsingTreeNode::build(Self::DUMMY_START_SYMBOL.into(), String::new(), Vec::new()),
            0,
        ));

        loop {
            let token_node = &tokens[shift_index].to_tree_node();

            let action = self
                .action_table
                .get_action(stack.last().unwrap().1, &token_node.symbol_type);

            match action {
                Some(Action::Shift(next_state)) => {
                    // shift
                    stack.push(NodePair::new(
                        tokens[shift_index].to_tree_node(),
                        *next_state,
                    ));
                    shift_index += 1;
                }
                Some(Action::Reduce(derivation)) => {
                    // pop right hand
                    let mut children: Vec<ParsingTreeNode> = Vec::new();
                    let mut datas = Vec::new();
                    for _ in 0..derivation.right.len() {
                        if let Some(top) = stack.pop() {
                            datas.push(top.0.data.clone());
                            children.push(top.0);
                        } else {
                            Err("parsing error: stack is empty.")?;
                        }
                    }

                    let children: Vec<_> = children.into_iter().rev().collect();
                    let datas: Vec<_> = datas.into_iter().rev().collect();
                    let handler = self.handlers.get(&derivation).unwrap();

                    // if the left hand side is dummy start symbol
                    // do nothing
                    if derivation.left == Self::DUMMY_START_SYMBOL {
                        stack.push(NodePair(
                            ParsingTreeNode::build(
                                derivation.left.to_string(),
                                handler(datas),
                                children,
                            ),
                            0,
                        ));
                        continue;
                    }

                    // goto[top_state(stack), X]
                    if let Action::Shift(next_state) = self
                        .action_table
                        .get_action(stack.last().unwrap().1, &derivation.left)
                        .unwrap()
                    {
                        stack.push(NodePair(
                            ParsingTreeNode::build(
                                derivation.left.to_string(),
                                handler(datas),
                                children,
                            ),
                            *next_state,
                        ));
                    } else {
                        Err("parsing error: invalid Shift action.")?;
                    }
                }
                Some(Action::Accept) => {
                    let res = stack.pop().unwrap().0;
                    return Ok(res);
                }
                _ => {
                    Err("parsing error: unknown.")?;
                }
            }
        }
    }
}
